主  题：日报
汇报人：何米娜
日  期：2018年7月29日 星期天
内  容：
1.今日学习了的内容：
复习了这周的学习内容；

2.没有解决的问题：



3.明天的学习计划：
（1 JVM的第二，三章
（2 复习Servlet的原理
（3 两道算法
（4 30道选择题
（5 shiro的2个视频


4.学习任务完成度： （80）  %[注：0% ~ 100%]
5.对自己今天学习的满意度：（8）分 [注：1-10分]
6.对今天的学习做一句话的总结：
	继续努力
算法1：
题目：输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
/*
        ListNode p = list1,q = list2;
        ListNode head = new ListNode(-1);
        ListNode tail = head;
        while(p != null && q != null) {
            if(p.val < q.val) {
                tail =tail.next=p;
                p=p.next;
            }else {
                tail =tail.next = q;
                q = q.next;
            }
        }
        if(p != null) {
            tail.next = p;
        }
        if(q != null) {
            tail.next = q;
        }
        return head.next;
    }
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
/**
*输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
*/
public class Solution {
    public static boolean HasSubtree(TreeNode root1, TreeNode root2) {
        boolean result = false;
        if (root2 != null && root1 != null) {
            if(root1.val == root2.val){
                result = doesTree1HaveTree2(root1,root2);
            }
            if (!result) {
                result = HasSubtree(root1.left,root2);
            }
            if (!result) {
                result = HasSubtree(root1.right,root2);
               }
        }         
        return result;
    }
    public static boolean doesTree1HaveTree2(TreeNode node1, TreeNode node2) {        
        if (node2 == null) {
            return true;
        }       
        if (node1 == null) {
            return false;
        }
        if (node1.val != node2.val) {  
                return false;
        }
        return doesTree1HaveTree2(node1.left,node2.left) && doesTree1HaveTree2(node1.right,node2.right);
    }
}
*/
if(list1 == null){
           return list2;
       }
       if(list2 == null){
           return list1;
       }
        ListNode head=null;
       if(list1.val <= list2.val){
           head=list1;
           head = Merge(list1.next, list2);
       }else{
            head=list2;
           head = Merge(list1, list2.next);
       }
       return head;
}