日报格式:
主  题：日报
汇报人：陈鑫
日  期：2018年8月2日 星期四
内  容：
1.今日学习了的内容：
1）加深SSM框架的学习
2）Linux四个视频
3)一道算法题
4）算法基础视频第一章已结束
2.没有解决的问题：
1）算法没完成
3.明天的学习计划：
1）复习面试题
2）学习算法视频
3）学习JVM
4.学习任务完成度： （50%）%[注：0% ~ 100%]
5.对自己今天学习的满意度：（3）分 [注：1-10分]
6.对今天的学习做一句话的总结：基础才是关键，往往学习的过程中忽略一些重点。
附录：
算法1：剑指Offer
题目： 
/**
 * 题目描述
 * 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。
 * 如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。
 * 思路：左<根<右（前提是左不空/右不空）
 *      1. 先根据后续遍历得到根节点（最后一个元素就是根）
 *      2. 得到左右子树
 *      3. 递归检查左子树是否满足条件（左<根<右），满足，则进行下一步
 *      4. 先检查右子树：
 *          4.1 先检查是不是都大于根，满足，进行下一步
 *          4.2 再递归右子树
 *      5. 上述步骤都满足，则返回真，否则返回假
 *
 */
{代码}
public class Number_23 {
    public static void main(String[] args) {
        //int a[] = {4,8,6,12,16,14,10};
        int a[] = {};
        System.out.println(new Number_23().VerifySquenceOfBST(a));
    }
    public boolean VerifySquenceOfBST(int [] sequence) {
        if(sequence == null ||  sequence.length == 0){
            return false;
        }
        return judge(sequence, 0, sequence.length-1);
    }
    public boolean judge(int []a, int l, int r){
        if (l==r){
            return true;
        }
        boolean result = true;

        int root = a[r]; // 根节点
        int i=0;
        while (a[i] < root && i<r)  i++;  // 移动到右子树的起点的下标位置
        int mid = i;
        if(i > l){ // 左不空
            result = judge(a, l, i-1);   // 继续检查整个左子树是否符合二叉搜索树的定义
        }
        if(r > i && result){  // 右不空,且左子树已经满足条件
            while (a[i] > root && i<r) i++;  //检查右子树是否都大于根
            if (i != r) {
                result =  false;
            }else {
                result = judge(a, mid, r-1);   // 继续检查整个右子树是否符合二叉搜索树的定义
            }
        }
        return result;
    }
}
算法1：剑指Offer
题目：基础再学习之归并排序
{代码}
/**
 * 八大排序之归并排序
 * 外部排序：因为在合并时，需要一个额外的数组
 * 时间复杂度：O(nlogn)
 * 空间复杂度：O(n)-----因为用了一个辅助数组
 *
 * 这里面要注意，求两个数的中点时，注意溢出问题
 * int mid = (L + R) / 2; // 这种方法不安全，当数很大的时候，(L+R)可能会大于int最大值，导致溢出
 * int mid = L + (R - L) / 2;
 */
public class Code_05 {
    public static void main(String[] args) {
        int []arr = {3,2,5,8,4,9};
        mergeSort(arr);
        for (int i: arr) {
            System.out.print(i + ", ");
        }
    }
    public static void mergeSort(int []arr){
        if (arr == null || arr.length < 2)
            return;
        divide(arr, 0, arr.length - 1);

    }
    public static void divide(int arr[], int L, int R){
        if (L ==  R)
            return;
        // int mid = (L + R) / 2; // 这种方法不安全，当数很大的时候，(L+R)可能会大于int最大值，导致溢出
        int mid = L + (R - L) / 2;
        divide(arr, L, mid);
        divide(arr, mid + 1, R);
        merge(arr, L, mid, R);

    }
    public static void merge(int []arr, int L, int M, int R){
        // B[2,3,  1,7]
        int []b = new int[R - L + 1];
        int p1 = L;
        int p2 = M+1;
        int i = 0;
        while (p1 <= M && p2 <= R )
            b[i++] = arr[p1] <= arr[p2] ? arr[p1++]:arr[p2++];
        // 两个肯定有一个是没有放完的
        while (p1 <= M)
            b[i++] = arr[p1++];
        while (p2 <= R)
            b[i++] = arr[p2++];
        // 拷贝回数组arr
        for (i = 0; i < b.length; ++i)
            arr[L + i] = b[i];  // 因为起点是L，所以加上 L
    }
}


【学习内容真实可靠，给自己的评分和完成度客观真实，不谦虚，不夸大】
