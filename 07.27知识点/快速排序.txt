package com.rank.Quick;

/**
 * 基于分治的思想，是冒泡排序的改进型。首先在数组中选择一个基准点（该基准点的选取可能影响快速排序的效率，后面讲解选取的方法），
 * 然后分别从数组的两端扫描数组，设两个指示标志（lo指向起始位置，hi指向末尾)，
 * 首先从后半部分开始，如果发现有元素比该基准点的值小，
 * 就交换lo和hi位置的值，然后从前半部分开始扫秒，发现有元素大于基准点的值，就交换lo和hi位置的值，如此往复循环，
 * 直到lo>=hi,然后把基准点的值放到hi这个位置。一次排序就完成了。
 * 以后采用递归的方式分别对前半部分和后半部分排序，当前半部分和后半部分均有序时该数组就自然有序了。
 *
 * 基准位置的选取一般有三种方法：固定切分，随机切分和三取样切分。
 * 固定切分 (数组中选择一个基准点） 的效率并不是太好，
 * 时间复杂度为O(NlogN).
 */

public class base {
    public static void main(String[] args){
        int[] data={3,2,4,7,6,1,8,5,6,5,1116,68};

        Quicksort(data,0,data.length-1);
        for(int i=0;i<data.length;i++){
            System.out.print(data[i]+" ");
        }

    }

    public static void Quicksort(int[] array,int lo,int hi){
        if(lo<hi) {
            int index = partition(array, lo, hi);
            //基准值的左边；即小于基准值
            Quicksort(array, lo, index - 1);
            //基准值的右边；即大于基准值
            Quicksort(array, index + 1, hi);
        }
    }

    public static int partition(int[] array,int lo,int hi){
        // 选择array的第一个为基准值
        int key=array[lo];
        while (lo<hi){
            //若右部分大于key,不交换值，hi--;继续比下一个
            while(array[hi]>=key&&hi>lo){
                hi--;
            }
            //a.在这里不用中间变量，在原数组中产生俩个相同值
            array[lo]=array[hi];
            //若左部分小于key,不交换值，lo++;继续比下一个   注意最后一个条件
            while(array[lo]<=key&&hi>lo){
                lo++;
            }
            array[hi]=array[lo];
        }
        //b.在原数组中，hi，lo指向同一个值；且为副本
        array[hi]=key;
        return hi;
    }
}
package com.rank.Quick;
/**
 * 随机切分是常用的一种切分，效率比较高，最坏情况下时间复杂度有可能为O(N^2)
 * 在每一次划分的时候随机选取一个元素作为关键字，用它来进行划分。
 *
 * 利用rand产生随机数  ，其中pivoIndex是关键字的下标，通过随机产生; pivotkey是对应该下标的数组元素值,；
 * 其次就是要注意随机数产生要在start和end的范围之内，可以通过设置偏移量(+low)来实现
 */

public class Rand {

    // 交换数组中的两个元素
    public static void exchange(int[] array, int index1, int index2) {
        int tmp = array[index1];
        array[index1] = array[index2];
        array[index2] = tmp;
    }

    // 分区函数,返回分区的元素下标
    public static int partition(int[] array, int start, int end) {
        if (start >= end)
            return -1;
        int length = end - start + 1;
        // 产生一个[start.. end]范围内的伪随机下标
        int pivotIndex = start + (int) Math.floor(Math.random() * length);
        System.out.println("选取的主元下标为: " + pivotIndex);
        // 选取array[pivotIndex]作为主元
        exchange(array, pivotIndex, end);
        int i = start;
        int j = end - 1;
        while (i < j) {
            // 从数组头部开始,依次找到数组中大于主元的元素
            while (i <= end && array[i] < array[end])
                ++i;
            // 从数组尾部开始,依次找到数组中小于主元的元素
            while (j >= start && array[j] >= array[end])
                --j;
            if (i < j) {
                exchange(array, i, j);
                ++i;
                --j;
            }
        }
        if (i > j) {
            exchange(array, i, end);
            return i;
        }
        // i == j的两种情况
        else if (array[i] > array[end]) {
            exchange(array, i, end);
            return i;
        } else {
            exchange(array, i + 1, end);
            return i + 1;
        }
    }

    // 真正的随机快速排序算法要开始了
    public static void quickSort(int[] array, int start, int end) {
        if (start < end) {
            int middle = partition(array, start, end);
            quickSort(array, start, middle - 1);
            quickSort(array, middle + 1, end);
        }
    }

    public static void main(String[] args){
        int[] data={6,3,7,4,1};

        quickSort(data,0,data.length-1);
        for(int i=0;i<data.length;i++){
            System.out.print(data[i]+" ");
        }

    }

}
package com.rank.Quick;

public class Helan {
    private static  void swap(int[] array,int i,int j){
        int temp =array[j];
        array[j]=array[i];
        array[i]=temp;
    }
    //从前到后，以传过来的数组的最后一个元素为基准，进行比较
    //大于基准值的向后交换； 小于基准值的向前交换； 相等的原地不动
    private static int[] sort(int[] arr,int left,int right){
        int less=left,more=right-1;
        int i=left;
        while(more>=i){
            if(arr[i]>arr[right]){
                swap(arr,i,more--);
            }else {
                if(arr[i]<arr[right]){
                    swap(arr,i,less++);
                }
            }
            i++;
        }
        swap(arr,right,more+1);
        return new int[]{less-1,more+1};
    }

    private static void quicksort(int[] arr,int left,int right){
        if(right>left){
            int[] p=sort(arr,left,right);
            quicksort(arr,left,p[0]);
            quicksort(arr,p[1],right);
        }
    }

    public static void main(String[] args){
        int arr[]={2,2,2,0,2,0,1,2,1,2,3,4};
        quicksort(arr,0,arr.length-1);
        for(int i=0;i<arr.length;++i){
            System.out.print(arr[i]+" ");
        }
    }

}
