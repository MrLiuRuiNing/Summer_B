类Object是类层次结构的根类。每个类都使用Object作为超类。所有对象(包括数组)都实现这个类的所有方法。

//*一个本地方法,具体是用C(C++)在DLL中实现的,然后通过JNI(Java Native Interface)调用.
//将.java文件中声明的本地方法，同过Javah调用得到一个本地方法需要的头文件.h文件
//再通过c编译器和链接器将.h文件与.c文件中实现的本地方法链接，放入共享库中，再用jvm调 用
private static native void registerNatives();
//对象初始化时自动调用
static{
    registerNatives();
}

//*返回此Object的运行时类
//用final修饰，不能被子类修改
public final native Class<?> getClass();                

hashCode的常规协定是： 
1.在java应用程序执行期间,在对同一对象多次调用hashCode()方法时,必须一致地返回相同的整数,前提是将对象进行equals比较时所用
的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行,该整数无需保持一致。
2.如果根据equals(object)方法,两个对象是相等的,那么对这两个对象中的每个对象调用hashCode方法都必须生成相同的整数结果。
3.如果根据equals(java.lang.Object)方法,两个对象不相等,那么对这两个对象中的任一对象上调用hashCode()方法不要求一定生成不同的整数结果。但是,为不相等的对象生成不同整数结果可以提高哈希表的性能。

如何解决哈希冲突：
1：线性探测法
2：线性补偿： 数组的长度的与补偿成质数
3：拉链法:利用头插法
4：建立公共溢出区
5:二重哈希
public native int hashCode();

//equals（obj）方法最根本的实现就是‘==’，因此对于一些自定义类，如果没有重写hashcode（）方法和equals（）方法的话，利用‘==’和equals()方法
//比较的结果是一样的。对于‘==’比较的是地址，equals()方法比较的是内容这种说法，是片面的。（虽然在最常用的String类中是这样的）。
public boolean equals(Object obj){
    return (this == obj);
}
 
//这个也是本地方法。需要注意的是该方法是“浅拷贝”的。
//浅拷贝：如果一个对象内部还有一个引用类型的基本变量，那么再拷贝该对象的时候，只是在通过clone方法新产生的新对象中拷贝一个该引用类型的引用。
//换句话说，也就是新对象和原对象他们内部都含有一个指向同一对象的引用。
//深拷贝：拷贝对象的时候，如果对象内部含有一个引用类型类型的变量，那么就会再将该引用类型的变量指向的对象复制一份，然后引用该新对象。
//clone()不调用构造方法
protected native Object Clone() throws CloneNotSupportedException;

//返回该对象的字符串表示,非常重要的方法 getClass().getName();获取字节码文件的对应全路径名例如java.lang.Object 
//Integer.toHexString(hashCode());将哈希值转成16进制数格式的字符串。
public String toString(){
    return getclass.getName()+"@"+Integer.toHexString(hashCode());
}

//这2个方法应当仅仅被拥有对象监视器的线程所调用。而一个线程成为对象的监视器的拥有者有三种方法:
//<1执行该对象上的一个同步（synchronized）方法
//<2执行一个同步在在对象上的代码块
//<3执行该对象的类上的静态同步方法
public final native void notify();/*随机唤醒在此对象监视器上等待的单个线程 优先考虑优先级*/
public final native void notifyAll(); /*唤醒在此对象监视器上等待的所有线程*/

//在其他线程调用此对象的notify()方法或notifyAll()方法前,导致当前线程等待。换句话说,此方法的行为就好像它仅执行wait(0)调用一样。 
//当前线程必须拥有此对象监视器。该线程发布对此监视器的所有权并等待,直到其他线程通过调用notify方法或notifyAll方法通知在此对象的监视器上等待的线程醒来,然后该//线程将等到重新获得对监视器的所有权后才能继续执行。
//调用该方法会抛出中断异常（InterruptedException），调用时应该用try catch捕捉。
public final void wait() throws InterruptedException{
    wait(0);//0表示没有时间限制
}

//该方法使当前线程等待，直到另外一个线程调用该对象的notify或notifyAll方法，或者等待时间已到，当前线程才会从等待池移到运行池。 
//第三种：如果在wait之前或者wait的时候，当前线程被中断了，那么直到该线程被恢复的时候才会抛出中断异常（InterruptedException）。
public final native void wait(long timeout) throws InterruptedException; 
public final void wait(long timeout, int nanos) throws InterruptedException {
    if(timeout < 0){ 
        throw new IllegalArgumentException("timeout value is negative");
     } 
    //nanos不能大于等于1000000ms也就是1000s 
    if(nanos < 0 || nanos > 999999){ 
        throw new IllegalArgumentException("nanosecond timeout value out of range"); 
    } 
        if(nanos>0)){
         timeout++;
   } 
    wait(timeout); 
}

//垃圾回收器在认为该对象是垃圾对象的时候会调用该方法。将该对象进行标记。后JVM的垃圾回收器去扫描标记。子类可以通过重写该方法来达到源释放的目的。 
//在方法调用过程中出现的异常会被忽略且方法调用会被终止。 
//任何对象的该方法只会被调用一次。
protected void finalize() throws Throwable{}                                 


