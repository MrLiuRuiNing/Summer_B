日报格式:
主  题：日报
汇报人：陈文通
日  期：2018年7月25日 星期三
内  容：
今日学习了的内容：


没有解决的问题：
2）根据中序前序由递归重建二叉树
明天的学习计划：
1）跟随老师学习Spring框架
2）算法练习
3）Linux视频学习
4.学习任务完成度： （80%）%[注：0% ~ 100%]
5.对自己今天学习的满意度：（70）分 [注：1-10分]
6.对今天的学习做一句话的总结：意识到自己算法还是有点差
附录：
算法1：
题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍      历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列      {4,7,2,1,5,3,8,6}，则重建二叉树并返回。（非递归实现，存在BUG，当测试用例超过接收数组      容量时，会出现数组越界问题）
 /**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        int i = 0;
		int len = pre.length;
		int j = 0;
		int k1 = 0;
		int k2 = 0;
		int temp = 0;
		TreeNode[] t = new TreeNode[len];
		for (i = 0; i < len; i++) {
			t[i] = new TreeNode(pre[i]);
			t[i].left=t[i].right=null;
		}
		// 找到根节点,分左右两边挂链
		for (j = 0; j < len - 1; j++) {
			if (j == 0 || j != temp) {
				for (i = 0; i < len; i++) {
					if (pre[j] == in[i]) {
						if (j == 0)
							temp = i;
						k1 = i;
						break;
					}
				}
				for (i = 0; i < len; i++) {
					if (pre[j + 1] == in[i]) {
						k2 = i;
						break;
					}
				}
				if (k2 < k1) {
					t[j].left = t[j + 1];
					t[j].right=null;
				}
				else {
					if(k2-k1==1)
					   t[j].right = t[j + 1];
					else {
						t[j-1].right=t[j+1];
					}
				}
				t[j + 1].left = t[j + 1].right = null;

			}
			else {
				t[0].right=t[j+1];
			}
		}

		return t[0];
    }
}
算法2：
题目：
{代码}
【学习内容真实可靠，给自己的评分和完成度客观真实，不谦虚，不夸大】