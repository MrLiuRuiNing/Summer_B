主  题：日报
汇报人：何米娜
日  期：2018年7月25日 星期三
内  容：
1.今日学习了的内容：
1)json的学习
2）八个基本包装类
3）两道算法题
4）30道选择题
5）异常的知识点
6)MyBatis的代码
7)小demo的实现

2.没有解决的问题：
1）MyBatis的代码
2）小demo的实现前端


3.明天的学习计划：
1)String源码的学习
2)快速排序的三种方法
3）小demo的实现前端

4.学习任务完成度： （80）  %[注：0% ~ 100%]
5.对自己今天学习的满意度：（8）分 [注：1-10分]
6.对今天的学习做一句话的总结：
	继续努力
算法1：
题目：
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 
输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 
例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

代码：
package com.erwei.array;
/**
 * 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，
 * 输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，
 * 该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。
 * @author Lenovo
 *解题思路：旋转数组的普遍特点：第一个元素的值大于等于最后一个元素
 *若采用顺序遍历查找最小值，时间复杂度为O(n);
 *利用最小值将数组分为两部分采用二分查找的方法，时间复杂度为O(logn)
 *
 *index1指向前一部分;index2指向后一部分
 *结束条件为：index2-index==1，则使indexmid=index2;返回index2
 */
public class Rotatearray {
	public static int min(int[] numbers, int length) {
		if(length==0){
			System.out.println("旋转数组为空");
		}
		int index1=0;
		int index2=length-1;
		int indexmid=index1;
		
		while(numbers[index1]>=numbers[index2]){
			//结束条件
			if(index2-index1==1){
				indexmid=index2;
				break;
			}
			indexmid=(index1+index2)/2;
			if(numbers[index1]==numbers[indexmid]&&numbers[index2]==numbers[indexmid]){
				return minInorder(numbers,index1,index2);
			}
			if(numbers[indexmid]>=numbers[index1]){
				 index1=indexmid;
			}else if(numbers[indexmid]<=numbers[index2]){
				 index2=indexmid;
			}
		}
		return numbers[indexmid];
	}
	public static int minInorder(int[] numbers, int index1, int index2) {
		int result=numbers[index1];
		for(int i=index1+1;i<=index2;++i){
			if(numbers[i]<result){
				result=numbers[i];
			}
		}
		return result;
	}
	public static void main(String[] args) {
		int[] numbers={3,4,5,1,2};
		//int[] numbers={1,0,1,1,1};
		int min=min(numbers,numbers.length);
		System.out.println(min);
	}
}

算法2：
题目：现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0），n<=39

代码：
package com.xxy.digui;
/**
 * 现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n<=39
 */

import java.util.Scanner;

public class Fibonacci {
	public static void main(String[] args) {
		Scanner scan=new Scanner(System.in);
		int n=scan.nextInt();
		//long lo=Fibonacci1(n);
		long lo=Fibonacci2(n);
		System.out.println(lo);
	}
	//先算出f0,f1->f2;f1,f2->f3;f2,f3->f4以此类推，时间复杂度为O(n);
	public static long Fibonacci2(int n) {
		int[] result={0,1};
		if(n<2){
			return result[n];
		}
		long fibminusone=1;
		long fibminustwo=0;
		long fibn=0;
		for (int i = 2; i <=n; i++) {
			fibn=fibminusone+fibminustwo;
			fibminustwo=fibminusone;
			fibminusone=fibn;
		}
		return fibn;
	}
	//可以用树的方式表现出来，但具有大量重复的结点；时间复杂度以指数的形式成倍地增长
	public static long Fibonacci1(int n) {
		if(n<=0){
			return 0;
		}
		if(n==1){
			return 1;
		}
		return Fibonacci1(n-1)+Fibonacci1(n-2);
	}
}


