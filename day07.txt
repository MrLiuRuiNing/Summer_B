日报格式:
主  题：日报
汇报人：陈鑫
日  期：2018年7月29日 星期天
内  容：
1.今日学习了的内容：
1）三道算法题
2）Spring事务管理
2.没有解决的问题：
1）Spring整合Mybatis没完成
3.明天的学习计划：
1）继续学习Spring，明天一定要将Spring和Mybatis整合，并开始准备搭建SSM
2）三道算法题
3）在上面的任务完成的基础上，最好在学习算法视频
4.学习任务完成度： （60%）%[注：0% ~ 100%]
5.对自己今天学习的满意度：（6）分 [注：1-10分]
6.对今天的学习做一句话的总结：成功在于坚持，依然坚信，如果你付出了，一定会有回报的。
附录：
算法1：剑指Offer
题目： * 题目描述：
 * 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，
 * 例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
 * 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.
 * | 1， 2， 3，  4|
 * | 5， 6， 7，  8|
 * |9， 10，11， 12|
 * |13，14，15，16|
{代码}
public class Number_19 {
    public static void main(String[] args) {
         //int [][]matrix = {{1, 2 ,3, 4},{ 5, 6, 7, 8},{ 9, 10, 11, 12}, {13, 14, 15, 16}};
         //int [][]matrix = {{1}};
        //int [][]matrix = {{1,2,3,4,5},{6,7,8,9,10},{11,12,13,14,15},{16,17,18,19,20},{21,22,23,24,25}};
        //int [][] matrix = null;
        int [][]matrix = {{1},{2},{3},{4},{5}};
        List<Integer> list = new Number_19().printMatrix(matrix);

        for (Integer i: list
             ) {
            System.out.println(i);
        }
    }
    public ArrayList<Integer> printMatrix(int [][] matrix) {
        if(matrix == null){
            return null;
        }
        ArrayList<Integer> list = new ArrayList <Integer>();

        int n = matrix.length; //行数
        int m = matrix[0].length; // 列数
        int layers = (Math.min(n,m)-1)/2+1;//这个是层数
        for(int k=0; k<layers; ++k){
           for(int j=k; j<m-k; ++j){ //m次循环，一行有m个数
               list.add(matrix[k][j]);
           }
           for(int i=k+1; i<n-k;++i ){// n-1次循环，一列有n个数，但是上面输出“一行”时，已经输出过了
               list.add(matrix[i][m-1-k]);
           }
           for(int j=m-k-2; (j>=k)&& k!=(n-k-1); --j){  //为了避免和上一层最后一个元素重复，故列数在向左偏移一个
               list.add(matrix[n-k-1][j]);
           }
           for(int i=n-k-2; (i>k)&&k!=(m-k-1); --i){ // 不能和起始是同一列，避免重复
               list.add(matrix[i][k]);
           }
        }
        return list;
    }

}
算法2：剑指Offer
题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。
 * 假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，
 * 序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。
 * （注意：这两个序列的长度是相等的）
{代码}
/**
 * 时间复杂度：O(n+m)
 * 空间复杂度：O(1)
 */
public class Number_21 {
    public static void main(String[] args) {
        int []pushA = {1,2,3,4,5};
        int []popA = {4,5,3,2,1};
        //int []popA = {4,3,5,1,2};
        System.out.println(IsPopOrder(pushA,popA));
    }
    public static boolean IsPopOrder(int [] pushA,int [] popA) {
        Stack<Integer> stack = new Stack<Integer>();
        int length = pushA.length;
        for(int i=0, j=0;i<length; ++i){
            stack.push(pushA[i]);
            while( j<length && stack.peek()==popA[j] ){ //如果入栈出栈顺序对应，则直接出栈
                stack.pop();
                j++;
            }
        }
        if(stack.empty())   return true;
        return false;
    }
}

算法3：剑指Offer
题目：从上往下打印出二叉树的每个节点，同层节点从左至右打印。
{代码}
public class Number_22 {
    public ArrayList<Integer> PrintFromTopToBottom(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        ArrayList<Integer> list = new ArrayList<>();
        if (root == null){
            return list;
        }
        queue.offer(root); // 根结点入队
        while (!queue.isEmpty()){
            TreeNode node = queue.poll();
           list.add(node.val);
            if (node.left != null) {
                queue.offer(node.left);
            }
            if (node.right != null) {
                queue.offer(node.right);
            }
        }
        return list;
    }


}

  /**
 * 利用栈的先进先出，来实现链表反转
 */
public class Number_15 {
    public static void main(String[] args) {
        int []arr = {5,4,3,2,1};
        ListNode head = new ListNode(5);
        ListNode h = head;
        for(int i=1; i<5; ++i){
            h.next = new ListNode(arr[i]);
            h = h.next;
        }
        head = new Number_15().ReverseList(head);
        while (head != null){
            System.out.println(head.val);
            head = head.next;
        }
    }
    public ListNode ReverseList(ListNode head) {
        if(head == null){
            return null;
        }
        Stack<ListNode> stack = new Stack<ListNode>();
        while(head != null){
            stack.push(head);
            head = head.next;
        }
        head = stack.pop();
        ListNode h = head;
        while (!stack.empty()){
            head.next = stack.pop();
            head = head.next;
        }
        head.next =null; // 将尾部元素置空，否则会出现最后两个元素相互引用
        return h;
    }
}


【学习内容真实可靠，给自己的评分和完成度客观真实，不谦虚，不夸大】
