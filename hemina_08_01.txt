主  题：日报
汇报人：何米娜
日  期：2018年8月1日 星期三
内  容：
1.今日学习了的内容：
（1 shiro的3个视频
（2 Springboot的视频
（3 三道算法

2.没有解决的问题：
（1 shrio程序有个Bug


3.明天的学习计划：
（1 shiro的2个视频
（2 Springboot的视频


4.学习任务完成度： （80）  %[注：0% ~ 100%]
5.对自己今天学习的满意度：（8）分 [注：1-10分]
6.对今天的学习做一句话的总结：
	继续努力

算法1：
题目：
/*
输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。
假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈
序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列；
（注意：这两个序列的长度是相等的）
*/
import java.util.ArrayList;
import java.util.Stack;
/**
若已知栈的压入顺列，判断popA序列是否为该栈的弹出顺序
<1 序列为空，两个序列的长度不相同  则认为popA序列不为该压入序列的弹出顺序
<2 若序列不空，使用一个辅助栈
       利用popA序列长度，控制辅助栈的压入次数
       若弹出的数值==辅助栈的栈顶值  直接将压入元素弹出
       若不相等，则将其压入辅助栈中，直至相等    ps:若在遍历压入序列时，找不到与弹出的数值，出循环；但若长度超出压入序列，出错
       
           
*/
public class Solution {
    public boolean IsPopOrder(int [] pushA,int [] popA) {
        if(pushA == null || popA == null || pushA.length == 0 || popA.length == 0 || pushA.length != popA.length) return false;
        Stack<Integer> st = new Stack<Integer>();
        int i = 0;
        int j = 0;
        st.push(pushA[i++]);
        while(j <= popA.length-1){
            while(popA[j] != st.peek()){
                if(i == pushA.length) return false;
                st.push(pushA[i++]);
            }
            j++;
            st.pop();
        }
        return true;
    }
}
算法2：从上往下打印出二叉树的每个节点，同层节点从左至右打印
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
//此题利用了一个双端队列，每遍历到一个根节点时将其左右子节点加入队列
public class Solution {
    public ArrayList<Integer> PrintFromTopToBottom(TreeNode root) {
        ArrayList list =new ArrayList();
        if(root==null) return list;
        Deque<TreeNode> deque = new LinkedList<TreeNode>();
         
         deque.add(root);
         while(!deque.isEmpty()){
             TreeNode t = deque.pop();
             list.add(t.val);
             if(t.left != null) deque.add(t.left);
             if(t.right != null) deque.add(t.right);
         }
         return list;

}
