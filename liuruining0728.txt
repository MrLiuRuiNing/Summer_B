主  题：日报
汇报人：刘睿宁
日  期：2018年7月28日 星期六
内  容：
1.	今日学习了的内容：
1）	练习命令
2）	项目设计用例图，er图
2.	没有解决的问题：
1）	框架学习较少
3.	明天的学习计划：
1）学习mybatis
2）Linux系统中各种软件的安装
4.学习任务完成度： （30）%[注：0% ~ 100%]
5.对自己今天学习的满意度：（3）分 [注：1-10分]
6.对今天的学习做一句话的总结：第一次做项目问题颇多
附录：
算法1：
题目：
/*
 * 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
 * 例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。
 * 
 * */

class TreeNode 
{
	 int val;
	 TreeNode left;
     TreeNode right;
     TreeNode(){val=-1;}
	 TreeNode(int x) { val = x; }
}
public class ReBuild_twoTree {
		 public TreeNode reConstructBinaryTree(int [] pre,int [] in)
		 {
			 if(pre == null || in == null || pre.length != in.length )//如果先序或者中序数组有一个为空的话，就无法建树，返回为空
				 return null;
			 else
			 {
				 return reBulidTree(pre,0,pre.length-1,in,0,in.length-1);
			 }
		 }
		 private TreeNode reBulidTree(int[] pre,int startPre,int endPre,int[] in,int startIn,int endIn)
		 {
			 if(startPre > endPre || startIn > endIn)//先对传的参数进行检查判断
				 return null;
			 int root = pre[startPre];
			 //数组的开始位置的元素是根元素
			 int locateRoot = locate(root,in,startIn,endIn);
			 //得到根节点在中序数组中的位置 左子树的中序和右子树的中序以根节点位置为界
			 if(locateRoot == -1) //在中序数组中没有找到跟节点，则返回空
			   return null;
			 TreeNode treeRoot = new TreeNode(root);//创建树根节点
			 treeRoot.left = reBulidTree(pre,startPre + 1,startPre + locateRoot - startIn,in,startIn,locateRoot-1);//递归构建左子树
			 treeRoot.right = reBulidTree(pre,startPre+locateRoot-startIn+1,endPre,in,locateRoot+1,endIn);//递归构建右子树
			 return treeRoot;
		 }
		 //找到根节点在中序数组中的位置，根节点之前的是左子树的中序数组，根节点之后的是右子树的中序数组
		 private int locate(int root,int[] in,int startIn,int endIn)
		 {
			 for (int i = startIn; i <= endIn; i++)
			{
				if(root == in[i])
					return i;
			}
			 return -1;
		 }
	public static void main(String[] args) {
		int[] a={1,2,3,4,5,6,7};
		int[] b= {3,2,4,1,6,5,7};
		TreeNode t= new TreeNode();
		ReBuild_twoTree r=new ReBuild_twoTree();
		t=r.reConstructBinaryTree(a,b);
		
	}

}

算法2：
题目2：
/*
 * 用两个栈来实现一个队列，完成队列的Push和Pop操作。 
 * 队列中的元素为int类型。
 * 
 * */
public class two_stack_queue {
	Stack<Integer> stack1 = new Stack<Integer>();
    Stack<Integer> stack2 = new Stack<Integer>();
    
    public void push(int node) {
        stack1.push(node);
    }
    
    public int pop() {
    	if(!stack2.isEmpty())  return stack2.pop();
    	if(stack1.isEmpty())  return -1;
    	while(!stack1.isEmpty())
    	 stack2.push(stack1.pop());
    	return stack2.pop();
    }
	public static void main(String[] args) {
		two_stack_queue t=new two_stack_queue();
		t.push(1);
		t.push(2);
		t.push(3);
		System.out.println(t.pop());
		System.out.println(t.pop());
	}

}

