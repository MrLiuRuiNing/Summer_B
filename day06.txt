日报格式:
主  题：日报
汇报人：陈鑫
日  期：2018年7月28日 星期六
内  容：
1.今日学习了的内容：
1）三道算法题
2）Spring整合jdbc
2.没有解决的问题：
1）git学习没有完成
2）Spring没有完成
3.明天的学习计划：
1）继续学习Spring，将Spring和Mybatis整合
2）两道算法题
3）复习Mybatis
4.学习任务完成度： （60%）%[注：0% ~ 100%]
5.对自己今天学习的满意度：（6）分 [注：1-10分]
6.对今天的学习做一句话的总结：成功在于坚持，依然坚信，如果你付出了，一定会有回报的。
附录：
算法1：剑指Offer
题目：输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。
{代码}
/**
 * 时间复杂度：O(n+m)
 * 空间复杂度：O(1)
 */
public class Number_16 {
    public static void main(String[] args) {
        int []arr = {1,3,5,7,9};
        ListNode head1 = new ListNode(arr[0]);
        ListNode h = head1;
        for(int i=1; i<5; ++i){
            h.next = new ListNode(arr[i]);
            h = h.next;
        }
        int []brr = {2,4,6,8,10};
        ListNode head2 = new ListNode(brr[0]);
        h = head2;
        for(int i=1; i<5; ++i){
            h.next = new ListNode(brr[i]);
            h = h.next;
        }
        head1 = new Number_16().Merge(head1,head2);
        while (head1 != null){
            System.out.println(head1.val);
            head1 = head1.next;
        }
    }
    public ListNode Merge(ListNode list1,ListNode list2) {
        if(list1 == null ){
            return list2;
        }
        if(list2 == null){      // list1不为null，list2为null，返回list1
            return list1;
        }
        // 下面都是list1，list2不为null的情况下进行的
        ListNode head = new ListNode(0);
        ListNode h = head;
        while (list1 != null && list2 != null){
            if(list1.val < list2.val){
                head.next = list1;
                list1 = list1.next;
            }else {
                head.next = list2;
                list2 = list2.next;
            }
            head = head.next;
        }
        if(list1 != null){
            head.next = list1;
        }
        if (list2 != null){
            head.next = list2;
        }

        return h.next;
    }

}


算法2：剑指Offer
题目：输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
		理解题意：子树的意思是包含了一个节点，就得包含这个节点下的所有节点
		子结构的意思是只要一部分相同就可以了
{代码}
/**思路：
 * 1.有一个树为空，则返回false
 * 2.遍历root1，找到第一个与root2相对于的根节点（广义优先，按行遍历）
 * 3.找到root1对应的root2根节点后，在进行匹配，如果不匹配，重复步骤2
 * 4.root1遍历完，结束
 */
public class Number_17 {
    /**
     *      8               8
     *    /   \           /   \
     *   8     9         2     7
     *  /\    /  \
     * 2  7   3   5
     */
    public static void main(String[] args) {

        TreeNode node1 = new TreeNode(8);
        node1.left = new TreeNode(2);
        node1.right = new TreeNode(7);
        TreeNode node2 = new TreeNode(9);
        node2.left = new TreeNode(3);
        node2.right = new TreeNode(5);
        TreeNode root1 = new TreeNode(8);
        root1.left = node1;
        root1.right = node2;

        TreeNode root2 = new TreeNode(8);
        root2.left = new TreeNode(2);
        root2.right = new TreeNode(5);

        boolean result = new Number_17().HasSubtree(root1,root2);
        System.out.println(result);


    }
    public boolean HasSubtree(TreeNode root1,TreeNode root2) {
        if(root1 == null || root2 == null){
            return false;
        }
        int cnt = 0;
        Queue<TreeNode> queue = new LinkedList();
        queue.offer(root1);
        while( ! queue.isEmpty()){
            TreeNode e = queue.poll();// 从队列中取出元素
            if(e.val == root2.val) { //找到root1对应的root2根节点后,进行匹配
                TreeNode p = e;
                TreeNode q = root2;
                Queue<TreeNode> queue1 = new LinkedList();
                queue1.offer(p);
                Queue<TreeNode> queue2 = new LinkedList();
                queue2.offer(q);
                cnt = 0;
                while(! queue1.isEmpty() && ! queue2.isEmpty()){
                    p = queue1.poll();
                    q = queue2.poll();

                    if( p.val != q.val){    // 不一致，则直接跳出循环
                        cnt = 1;
                        break;
                    }
                    if(p.left != null){
                        queue1.offer(p.left);
                    }
                    if(p.right != null){
                        queue1.offer(p.right);
                    }
                    if(q.left != null){
                        queue2.offer(q.left);
                    }
                    if(q.right != null){
                        queue2.offer(q.right);
                    }
                }
                if( cnt != 1 && queue2.isEmpty()){   // 所有元素一一对应，全部符合
                    return true;
                }
            }
            if(e.left != null){
                queue.offer(e.left);
            }
            if(e.right != null){
                queue.offer(e.right);
            }
        }
        return false;
    }
}

  /**
 * 利用栈的先进先出，来实现链表反转
 */
public class Number_15 {
    public static void main(String[] args) {
        int []arr = {5,4,3,2,1};
        ListNode head = new ListNode(5);
        ListNode h = head;
        for(int i=1; i<5; ++i){
            h.next = new ListNode(arr[i]);
            h = h.next;
        }
        head = new Number_15().ReverseList(head);
        while (head != null){
            System.out.println(head.val);
            head = head.next;
        }
    }
    public ListNode ReverseList(ListNode head) {
        if(head == null){
            return null;
        }
        Stack<ListNode> stack = new Stack<ListNode>();
        while(head != null){
            stack.push(head);
            head = head.next;
        }
        head = stack.pop();
        ListNode h = head;
        while (!stack.empty()){
            head.next = stack.pop();
            head = head.next;
        }
        head.next =null; // 将尾部元素置空，否则会出现最后两个元素相互引用
        return h;
    }
}
算法3：剑指Offer
题目：/**
 * 题目描述
 * 操作给定的二叉树，将其变换为源二叉树的镜像。
 * 输入描述:
 * 二叉树的镜像定义：源二叉树
 *     	    8
 *     	   /  \
 *     	  6   10
 *     	 / \  / \
 *     	5  7 9 11
 *     	镜像二叉树
 *     	    8
 *     	   /  \
 *     	  10   6
 *     	 / \  / \
 *     	11 9 7  5
 */
{代码}
/**
 * 思路：1. 广度优先遍历。对于每个非叶子节点，交换其左右子树
 */
public class Number_18 {
    public static void main(String[] args) {
        TreeNode node1 = new TreeNode(6);
        node1.left = new TreeNode(5);
        node1.right = new TreeNode(7);
        TreeNode node2 = new TreeNode(10);
        node2.left = new TreeNode(9);
        node2.right = new TreeNode(11);
        TreeNode root = new TreeNode(8);
        root.left = node1;
        root.right = node2;

        new Number_18().Mirror(null);

    }
    public void Mirror(TreeNode root) {
        if(root != null){       // 必须进行非空判断，才能入队列
            Queue<TreeNode> queue = new LinkedList<TreeNode>();

            queue.offer(root);
            while (!queue.isEmpty()){
                TreeNode e = queue.poll();
                if(e.left != null || e.right != null){ // 对于只有左子树/右子树，也是满足的。
                    TreeNode temp = e.left;
                    e.left = e.right;
                    e.right = temp;
                }
                if(e.left != null){
                    queue.offer(e.left);
                }
                if (e.right != null){
                    queue.offer(e.right);
                }
            }
        }
    }

}

【学习内容真实可靠，给自己的评分和完成度客观真实，不谦虚，不夸大】
